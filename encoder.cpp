#include "headerfiles/encoder.h"




encoder::encoder(string _filename, int capacity){

  bool has_dot = false;
  for(int i = 0; i < _filename.size(); i++){

    if(has_dot) original_extension.push_back(_filename[i]);
    if(_filename[i] == '.') has_dot = true;

  }

  filename       = _filename;
  bits           = new myarrlist<bool>(capacity);

}

encoder::~encoder(){

  delete bits;

}


/* Reads each characters of file: filename.
*  each time it reads a char it increments its frequency in
*  the char_map. for more information on char_map , refer to the char_map class.
*/
void encoder::load_chars_to(char_map * map){

  std::ifstream inputfile(filename, std::ifstream::in);

  char c;

  while(inputfile.get(c)){

    map->increment_char(c); // increments char c frequency.

  }

  inputfile.close();

}

/* convert each chars to bits sequence generated by the huffman_tree.
*  the bit sequence is represented in string and can vary in size.
*  the most frequent the string the less bits it contains.
*  refer to huffman tree for more detatils.
*/
void encoder::load_bits_from(char_map * map){

  std::ifstream inputfile(filename, std::ifstream::in);

  if(!inputfile.is_open()) {
    std::cout << "ERROR OPENING file : " << filename << " !" << std::endl;
  }

  char c;
  string buffer;

  // read through the file.
  while(inputfile.get(c)){

    //get string representation of bit sequence for char c.
    buffer = map->get_code(c);

    // append each bits to arraylist of bits in this class.
    for(int i = 0; i < buffer.size(); i++)
      bits->add( buffer[i] == '1' );

  }

  inputfile.close();

}

/*
* Writes the important data for file decompression.
*
* @param orig_extension is the original extension prior to compression.
* @param  characters is the list of characters along with their frequency.
*         characters is important data in order to rebuild the huffman_tree for decompression.
* @param extra_bits_count indicates the number of bits that are added if the total bit count
*                         is not a mulptiple of 8(char size in ascii). This amount
*                         will be subtracted to the last char of the compressed file in order to
*                         restore the original bit sequence.
*/
void encoder::write_heading( char_map * map){

 string new_file_name =  make_file_out_name();
 std::ofstream outputfile(new_file_name, std::ofstream::out | std::ofstream::trunc);
 string header(map->to_string());
 int extra_bits_count = NUM_OF_BITS - (bits->size() % NUM_OF_BITS);

 outputfile << map->get_char_node_count() << "|";
 outputfile << header                       ;
 outputfile << extra_bits_count       << "|";
 outputfile << original_extension     << "|";

 outputfile.close();

}


/* TODO fix the logic
* converts segments of bits back to char
*/
char encoder::bits_to_char(int begin_indx, const int length){

  int c = 0;
  int value = VALUE_OF_MSB;
  if((*bits)[begin_indx]){
    c += value;
  }// if


  value = (value * value) / value; // remove the sign of msb
  value /= 2;

  for(int i = begin_indx + 1;  i < (begin_indx + length); i++){

    if((*bits)[i]){
      c += value;
    }// if

    value /= 2;
  }// for


  return c;

}// bits_to_char


string encoder::make_file_out_name(){

  string outfile("");
  for(int i = 0; i < filename.size(); i++){

    if(filename[i] == '.') break;
      outfile += filename[i];

  }

  outfile += EXTENSION;

  return outfile;
}


/* main function for the encoder class.
* encode() convert the arrlist of bits into chars then
* writes back into the compressed file.
* encode() repackages the array of bits into 8 sets.
* each sets is then convert in to char(ascii) then is written into the compressed file.
* NOTE: encode() handles the case when the case when bit size is not a perfect
*       mulptiple of NUM_OF_BITS(for char so in this case is 8) by appending 0's the arraylist of bits.
*
*/
void encoder::encode(){


  string new_file_name =  make_file_out_name();
  std::ofstream outputfile(new_file_name, std::ofstream::out | std::ofstream::app);

  // handles case when bits size is not a mulptiple of 8.
  long long int extra_bits_count = NUM_OF_BITS - (bits->size() % NUM_OF_BITS);
  if( extra_bits_count!= 0 ){
    while (extra_bits_count > 0) {
      bits->add(0);
      extra_bits_count --;
    }
  }

  long long int last_indx = bits->size();
  long long int indx = 0;

  // repackages bits into 8 then writes it to the outputfile.
  while(indx < last_indx) {

    char c = bits_to_char(indx, NUM_OF_BITS);
    outputfile.put(c);
    indx += NUM_OF_BITS;

  }

  outputfile.close();

}
